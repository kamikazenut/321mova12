begin;

create table if not exists public.ratings (
  user_id uuid not null references auth.users(id) on delete cascade,
  media_id integer not null,
  media_type text not null check (media_type in ('movie', 'tv')),
  rating smallint not null check (rating between 1 and 10),
  created_at timestamp with time zone not null default now(),
  updated_at timestamp with time zone not null default now(),
  primary key (user_id, media_id, media_type)
);

create table if not exists public.comments (
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users(id) on delete cascade,
  media_id integer not null,
  media_type text not null check (media_type in ('movie', 'tv')),
  content text not null,
  created_at timestamp with time zone not null default now(),
  updated_at timestamp with time zone not null default now(),
  constraint comments_content_length_check check (char_length(trim(content)) between 1 and 1000)
);

create index if not exists ratings_media_idx on public.ratings (media_type, media_id);
create index if not exists ratings_user_idx on public.ratings (user_id);

create index if not exists comments_media_created_idx
  on public.comments (media_type, media_id, created_at desc);

create index if not exists comments_user_idx on public.comments (user_id);

alter table public.ratings enable row level security;
alter table public.comments enable row level security;

create or replace function public.set_updated_at()
returns trigger
language plpgsql
set search_path to ''
as $function$
begin
  new.updated_at = now();
  return new;
end;
$function$;

drop trigger if exists set_updated_at_ratings on public.ratings;
create trigger set_updated_at_ratings
before update on public.ratings
for each row
execute function public.set_updated_at();

drop trigger if exists set_updated_at_comments on public.comments;
create trigger set_updated_at_comments
before update on public.comments
for each row
execute function public.set_updated_at();

grant select on table public.ratings to anon;
grant select, insert, update, delete on table public.ratings to authenticated;
grant all privileges on table public.ratings to service_role;

grant select on table public.comments to anon;
grant select, insert, update, delete on table public.comments to authenticated;
grant all privileges on table public.comments to service_role;

grant usage, select on sequence public.comments_id_seq to authenticated, service_role;

drop policy if exists "Anyone can view ratings" on public.ratings;
create policy "Anyone can view ratings"
on public.ratings
as permissive
for select
to anon, authenticated
using (true);

drop policy if exists "Users can insert their own rating" on public.ratings;
create policy "Users can insert their own rating"
on public.ratings
as permissive
for insert
to authenticated
with check ((select auth.uid()) = user_id);

drop policy if exists "Users can update their own rating" on public.ratings;
create policy "Users can update their own rating"
on public.ratings
as permissive
for update
to authenticated
using ((select auth.uid()) = user_id)
with check ((select auth.uid()) = user_id);

drop policy if exists "Users can delete their own rating" on public.ratings;
create policy "Users can delete their own rating"
on public.ratings
as permissive
for delete
to authenticated
using ((select auth.uid()) = user_id);

drop policy if exists "Anyone can view comments" on public.comments;
create policy "Anyone can view comments"
on public.comments
as permissive
for select
to anon, authenticated
using (true);

drop policy if exists "Users can insert their own comment" on public.comments;
create policy "Users can insert their own comment"
on public.comments
as permissive
for insert
to authenticated
with check ((select auth.uid()) = user_id);

drop policy if exists "Users can update their own comment" on public.comments;
create policy "Users can update their own comment"
on public.comments
as permissive
for update
to authenticated
using ((select auth.uid()) = user_id)
with check ((select auth.uid()) = user_id);

drop policy if exists "Users can delete their own comment" on public.comments;
create policy "Users can delete their own comment"
on public.comments
as permissive
for delete
to authenticated
using ((select auth.uid()) = user_id);

create or replace function public.get_media_rating_stats(p_media_id integer, p_media_type text)
returns table (average_rating numeric(4,1), ratings_count bigint)
language sql
stable
set search_path to 'public'
as $function$
  select
    coalesce(round(avg(r.rating)::numeric, 1), 0)::numeric(4,1) as average_rating,
    count(*)::bigint as ratings_count
  from public.ratings r
  where r.media_id = p_media_id
    and r.media_type = p_media_type;
$function$;

grant execute on function public.get_media_rating_stats(integer, text) to anon, authenticated, service_role;

commit;
